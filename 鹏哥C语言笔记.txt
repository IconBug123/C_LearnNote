每日问题和扩展归总：
	1 动态和静态库
	2 回调函数     		√ 在鹏哥113
	3 数据库的使用		
	
要做的事情:
写一个动态内存的笔记, 里面包含15节内容

 ①
int main(){
  {
  	int a = 10;
	printf("%d\n", a);   //可以输出
  }
  printf("%d", a);	      //不可以输出，因为a定义的作用域是在上面的{}作用域里
}
在{}里的内容是代码块，只能在该{...}里面使用，在外面不能调用。


②
字符串的末尾有\0才能结束
char arr[] = {'a', 'b', '\0'};  //此处要有\0
printf("%s", arr);

arr[] = {1, 2, 3};
strlen(arr)     //此处不是3, 因为strlen只有到/0才停止

  
③
转义字符
\字符   表示其他含义。如\n, \0 ......


④
static是内部链接
extern是外部链接，因此不能extern int a；然后用static int a = 10；定义
如果用static int a = 10；则该变量只能在该文件使用，因为链接改变了
extern 声明的变量在file1.c，可以在其他文件里file2.c里定义，可以在任意文件里使用，由于是
外部链接属性因此不需要头文件。函数也可以用extern。
static如同把函数或是变量私有化，仅仅是声明时所在的文件可以用

register int num = 3；建议把num放到寄存器里，但不一定。
 

⑤
int* p1, p2, p3;
此处p1是指针，p2和p3是int变量
int* p1, *p2, *p3;


⑥
从C99之后才可以for(int i = 0; i<10; i++)在for里面赋值int i
通常：
int i = 0；
for(i=100; i<200; i++)

也可以多个变量 for(x = 1, y =2; x<4||y<7; x++, y++)


⑦
随机种子的使用：一个随机种子对应一个随机数表，每次设定好随机数种子后就会从该表里第一个开始顺序拿取随机数，如果每次都设置随机数表则都会先拿取该表的第一个数。


⑧
C语言里的函数的数组形参int arr[]与int* arr是一样的都是一个int的指针。
但是在函数里无法求得数组arr的size因为在函数里只是一个数组的首元素地址

函数里的形参int arr[][3] 和 int (*arr)[][3]的区别：
	前者int arr[][3] 是 &arr[0] 或 arr
	后者int (*arr)[][3] 是 &arr


⑨ 静态库 44集
通过该静态库的头文件和该静态库 add.lib（此处add名字是随意起的）
在主函数main里#pragma comment(lib, "add.lib")

 
⑩
在C99之后的数组可以用变量指定其size
如: int n = 10;
     int arr[n] = {};


⑩①
数组 int arr[10] 的类型是 int [10]

数组名是一个不可修改的左值


⑩②
蛋哥C语言深度解剖

*****      内存里存储的补码
正整数的原码=反码=补码
负整数的原码   反码=原码的符号位不变, 其他位按位取反  补码=反码+1

左移右移操作符只能对于正负整数，不能对浮点数
因此对于负整数而言左右移动的是他的补码

左移操作符：
左边移位，右边补0

右移操作符：
算术移位：右边丢弃，左边补原符号
逻辑移位：右边移位，左边补0

VS编译器采用的是算术移

常用的异或操作符
0^a = a
a^a = 0
a^b = b^a
(a^b)^c = a^(b^c)

*********按位操作符只是针对整数**********


 ⑩③
"string_1" == "string_2"比较的是他们的地址
strcmp(string_1, string_2);

逗号表达式：exp1, exp2, exp3, ...expN
从左向右执行, 整个表达式的结果是最后一个表达式的结果
例如：
int a = 1; int b = 2;
int c = (a++, a+b); 结果为 c = 4

操作符有优先级，但是计算时候要注意唯一路径，否则结果会不一致。



⑩④
(1) 指针变量+-1是对应的他的数据类型的步长。
(2) 指针的类型决定了他的步长和内容的存储方式(解引用后访问的内存大小，如char* 访问1byte)


⑩⑤

assert断言的使用：
assert(判断情况); 如果为真则继续下面的代码，否则在此处报错
例如: char* str = "abc";
	assert(str != NULL);  //或assert(str);

***!!!!!***
字符串可以理解为const char* 虽然变量内容不能修改，但可以修改它的指向到另一个字符串的地址
char* str_1 = "abc";
char* str_2 = "123;
str_1 = str_2;   //不能*str_1 = *str_2;修改元素内容

因此strcpy函数里的参数是char arr[] = "abc"; 不是字符串(由于字符串是常量), 而此处arr[]是一个字符数组

字符串有两种表达：const char* str = "abc";  char arr[] = "abc";


⑩⑥
数据的存储
数据在电脑里是以补码的形式存储，
char a = -1;
此处-1 = 1000 0000 0000 0000 0000 0000 0000 0001
该-1补码是: 1111 1111 1111 1111 1111 1111 (1111 1111)
转话为: char a是1个字节为低位的1111 1111并且是有符号的所以为：1111 1111→高位的1为符号
它对应int的补码：1111 1111 1111 1111 1111 1111 1111 1111 为-1
而unsigned int 此时就是1111 1111 1111 1111 1111 1111 1111 1111 就是原码 4294967295(此时高位的1不是符号)
但是unsigned char b = -1; 就是1111 1111
它对应int的补码：0000 0000 0000 0000 0000 0000 1111 1111 就是255
(1) 数据的正负类型对应的是字节前面补充的数字1或是0， 无符号类型补0，有符号类型补根据高位而定
(2) 数据的正负类型也说明它的补码的2进制的高位是否为符号还是非符号(原码=补码)

(原码的补码：正数原码=反码=补码；负数补码=原码的反码+1，补码的补码=原码)


⑩⑦  
void* 没有具体类型的指针, 但可以接受任何类型的指针，但是不能解引用操作 (因为没有具体类型就无法知道解引用后访问的内存大小，也不能+-整数进行步长运算)，所以要在解引用前进行类型转换 (转换为某个具体类型)

例如：
int a = 10;
void* ap = &a;
*(int*) ap;   //将ap强制转换为 int* 指针在解引用

回调函数 (第113在sqort函数里讲的)：当函数A通过它的函数指针Ap被另一个地方(可以是另一个函数通过函数指针参数)在某个情况调用时，则称函数A是回调函数，被另一个地方回调的函数


⑩⑧
strerror函数可以打印处错误信息, 错误信息保存在errno (int) 里面 #include <string.h>
char* strerror(errno);

