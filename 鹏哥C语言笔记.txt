每日问题和扩展归总：
	1 动态和静态库
	2 回调函数     		√ 在鹏哥113
	3 数据库的使用		
	
要做的事情:
写一个动态内存的笔记, 里面包含15节内容

 ①
int main(){
  {
  	int a = 10;
	printf("%d\n", a);   //可以输出
  }
  printf("%d", a);	      //不可以输出，因为a定义的作用域是在上面的{}作用域里
}
在{}里的内容是代码块，只能在该{...}里面使用，在外面不能调用。


②
Note that字符串的末尾有\0才能结束
char arr[] = {'a', 'b', '\0'};  //此处要有\0
printf("%s", arr);

arr[] = {1, 2, 3};
strlen(arr)     //此处不是3, 因为strlen只有到/0才停止

  
③
转义字符
\字符   表示其他含义。如\n, \0 ......


④
static是内部链接
extern是外部链接，因此不能extern int a；然后用static int a = 10；定义
如果用static int a = 10；则该变量只能在该文件使用，因为链接改变了
extern 声明的变量在file1.c，可以在其他文件里file2.c里定义，可以在任意文件里使用，由于是
外部链接属性因此不需要头文件。函数也可以用extern。
static如同把函数或是变量私有化，仅仅是声明时所在的文件可以用

register int num = 3；建议把num放到寄存器里，但不一定。
 

⑤
int* p1, p2, p3;
此处p1是指针，p2和p3是int变量
int* p1, *p2, *p3;


⑥
从C99之后才可以for(int i = 0; i<10; i++)在for里面赋值int i
通常：
int i = 0；
for(i=100; i<200; i++)

也可以多个变量 for(x = 1, y =2; x<4||y<7; x++, y++)


⑦
随机种子的使用：一个随机种子对应一个随机数表，每次设定好随机数种子后就会从该表里第一个开始顺序拿取随机数，如果每次都设置随机数表则都会先拿取该表的第一个数。


⑧
C语言里的函数里形参是数组int arr[]与int* arr是一样的，都是一个int的指针。
但是在函数里无法求得数组arr的size (sizeof)因为在函数里只是一个数组的首元素地址

函数里的形参int arr[][3] 和 int (*arr)[][3]的区别：
	前者int arr[][3] 是 &arr[0] 或 arr
	后者int (*arr)[][3] 是 &arr


⑨ 静态库  鹏哥C的44集 (目前作为了解)
通过该静态库的头文件和该静态库 add.lib（此处add名字是随意起的）
在主函数main里#pragma comment(lib, "add.lib")

 
⑩
在C99之后的数组可以用变量指定其size
如: int n = 10;
     int arr[n] = {};


⑩①
数组 int arr[10] 的类型是 int [10]

数组名是一个不可修改的左值


⑩②
蛋哥C语言深度解剖

*****      内存里存储的是数据的补码
正整数的原码=反码=补码
负整数的原码   反码=原码的符号位不变, 其他位按位取反  补码=反码+1

左移右移操作符只能对于正负整数，不能对浮点数
因此对于负整数而言左右移动的是他的补码

左移操作符：
左边移位，右边补0

右移操作符：
算术移位：右边丢弃，左边补原符号
逻辑移位：右边移位，左边补0

VS编译器采用的是算术移

常用的异或操作符
0^a = a
a^a = 0
a^b = b^a
(a^b)^c = a^(b^c)

*********按位操作符只是针对整数**********


 ⑩③
"string_1" == "string_2"比较的是他们的地址
strcmp(string_1, string_2);

逗号表达式：exp1, exp2, exp3, ...expN
从左向右执行, 整个表达式的结果是最后一个表达式的结果
例如：
int a = 1; int b = 2;
int c = (a++, a+b); 结果为 c = 4

操作符有优先级，但是计算时候要注意唯一路径，否则结果会不一致。



⑩④
(1) 指针变量+-1是对应的他的数据类型的步长。
(2) 指针的类型决定了他的运算时的步长 和 内容的存储方式(解引用后访问的内存大小，如char* 访问1byte)

数字常量没有地址(直接嵌入的到程序里的)，宏定义没有地址，const变量有地址，字符串有地址
指针是变量的初始地址 (一般是低地址) 一个地址的存储空间是1byte
占有不同字节大小的数据它们的存储方式是字节按照大小端存储 (大小端只是存储数据的字节byte的顺序)。char类型没有大小端之分

typedef 原有名字  newName;
typedef struct Name{....} newName;   
typedef char* String;	指针新名字String
typedef struct Node{int val; struct Node* next}Node, *NodePtr;     结构体指针  NodePtr   相当于struct Node*,  而 Node 相当于struct Node
typedef int(*FuncPtr)(int, char, ...);      该函数指针数据类型的新名字FunPtr



⑩⑤

assert断言的使用：
assert(判断情况); 如果为真则继续下面的代码，否则在此处报错
例如: char* str = "abc";
	assert(str != NULL);  //或assert(str);

***!!!!!***
字符串可以理解为const char* 虽然变量内容不能修改，但可以修改它的指向到另一个字符串的地址
char* str_1 = "abc";
char* str_2 = "123;
str_1 = str_2;   //不能*str_1 = *str_2;修改元素内容

因此strcpy函数里的参数是char arr[] = "abc"; 不是字符串(由于字符串是常量), 而此处arr[]是一个字符数组

字符串有两种表达：(1) 不可以修改内容 const char* str = "abc"; 
			       (2) 可以修改内容 char arr[] = "abc";


⑩⑥
数据的存储
数据在电脑里是以补码的形式存储，
char a = -1;
此处-1 = 1000 0000 0000 0000 0000 0000 0000 0001
该-1补码是: 1111 1111 1111 1111 1111 1111 (1111 1111)
转话为: char a是1个字节为低位的1111 1111并且是有符号的所以为：1111 1111→高位的1为符号
它对应int的补码：1111 1111 1111 1111 1111 1111 1111 1111 为-1
而char a它对应的unsigned int 此时就是1111 1111 1111 1111 1111 1111 1111 1111 就是原码 4294967295(此时高位的1不是符号)
但是unsigned char b = -1; 就是1111 1111
它对应int的补码：0000 0000 0000 0000 0000 0000 1111 1111 就是255
(1) 数据的正负类型对应的是字节前面补充的数字1或是0， 无符号类型补0，有符号类型补根据高位而定
(2) 数据的正负类型也说明它的补码的2进制的高位是否为符号还是非符号(原码=补码)

(原码的补码：正数原码=反码=补码；负数补码=原码的反码+1，补码的补码=原码)

数据都是二进制方式存储，但是为了方便阅读二进制的每4位都表示成一个16进制的数字，如1010 0110  表示为0XA6为一个字节(Note that 0X表示16进位)
8位(bit)是一个byte字节, char类型占用 1 byte
小端存储就是数据低字节存在低地址，反之大端存储就是数据低字节存在高地址
一个地址存储一个字节的内容 (空间大小) 所以char而言没有大小端因为就一个字节

int a = 0x12345678;（十进制 305419896）
如果是 小端（Little-Endian） 处理器：
地址  | 数据（二进制）  | 数据（十六进制）      
------|--------------|--------------
0x100 | 0111 1000    | 0x78
0x101 | 0101 0110    | 0x56
0x102 | 0011 0100    | 0x34
0x103 | 0001 0010    | 0x12
低地址 -> 78 56 34 12 <- 高地址

如果是 大端（Big-Endian） 处理器：
地址  | 数据（二进制）  | 数据（十六进制）
------|--------------|--------------
0x100 | 0001 0010    | 0x12
0x101 | 0011 0100    | 0x34
0x102 | 0101 0110    | 0x56
0x103 | 0111 1000    | 0x78



⑩⑦  
void* 没有具体类型的指针, 但可以接受任何类型的指针，但是不能解引用操作 (因为没有具体类型就无法知道解引用后访问的内存大小，也不能+-整数进行步长运算)，所以要在解引用前进行类型转换 (转换为某个具体类型)

例如：
int a = 10;
void* ap = &a;
*(int*) ap;   //将ap强制转换为 int* 指针在解引用
强制转化后的ap还是void*类型, 强制转换只是临时改变了ap的使用方法, 但实际的ap还是void*类型。

int b = 123;
void* bp = &b;
bp = (int*) bp + 1;  那么 bp 仍然是 void* 类型，只是在原有的地址上往后移动了4个字节

回调函数 (第113在sqort函数里讲的)：当函数A通过它的函数指针Ap被另一个地方(可以是另一个函数通过函数指针参数)在某个情况调用时，则称函数A是回调函数，被另一个地方回调的函数


⑩⑧
strerror函数可以打印处错误信息, 错误信息保存在errno (int) 里面 #include <string.h>
char* strerror(errno);


⑩⑨
结构体：
struct Name{
	int a; 
	char b;
	float c;
} s1, s2 = {12, 'a', 0.3};
此处如果结构体定义在main函数外部, 则为s1和s2为全局变量, 如果没有Name则是匿名结构体, 此时只能用s1, s2不能在创建其他的对象
也可以: struct Name s1;  也可以初始化

结构体的数据存储方式：
(1) 第一个变量存储在偏移量为0的起始地址处
(2) 其他变量存在  最小整数倍 of min(编译器默认对齐数与该变量字节大小的) 作为偏移量的地址处 (中间的字节空间都是空的)
(3) 结构体的占用的总空间是  整数倍 of max(所有变量对齐数)     各变量的对齐数是: min(编译器默认对齐数与该变量字节大小的)
(4) 结构体里嵌套了其他结构体，则该嵌套的结构体的所占总空间为自身大小，对齐到偏移量为自身里最大对齐数的整数倍，该空间总大小为 整数倍 of max(所有对齐数包括嵌套的结构体) 
(结构体自身的对齐数是自己内部的 max(内部变量的对齐数)) 

#pragm pack(4)  修改默认偏移数为4
#pragm pack()    修改回默认值


②⑩ （了解此处内容）
位段的成员必须是int, unsigned int  或 signed int，char 
struct A{
   int a : 2;
   int b : 3; 
};
说明a占用2个bit 从而可以分配空间大小
位段时int按照4byte，char按照1byte开辟空间 
位段不具有跨平台
位段的大小不能超过该类型的字节大小
      ☆☆☆ 位段最好不要使用，由于不同的系统分配空间情况不一样。所以不能跨平台。。。。除非写出不同平台的代码适应这些平台






